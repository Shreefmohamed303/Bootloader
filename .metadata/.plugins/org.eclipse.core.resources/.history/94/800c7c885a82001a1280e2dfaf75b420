/*
 * Bootloader.c
 *
 *  Created on: Apr 19, 2020
 *      Author: LENOVO
 */
#include"Bootloader.h"

/*****************************FUNCTION DEFINITION**************************************/

void BootLoader_Jump_to_User_APP()
{
	// Pointer to Function to hold the Reset_Handler() of the User Application code
	void (*PF_APP_Reset_handler)(void);

	printmsg("BL_DEBUG_MSG:Bootloader_jump_to_User_Application\r\n");

	/* 1. Configure the MSP_Value of User application
	 *    by Reading the value of the base address of Sector 2
	 */
	uint32_t user_MSP_value=*(volatile uint32_t *)FLASH_SECTOR2_BASE_ADDRESS;
	printmsg("BL_DEBUG_MSG:User_MSP_Value : %#x\r\n",user_MSP_value);

	// This Function Comes with CEMSIS
	__set_MSP(user_MSP_value);

	/* 2. Fetching The Reset Handler address of The User Application
	 * 	  From The Location (FLASH_SECTOR2_BASE_ADDRESS+4)
	 * 	  as it's the second location of the Flash memory
	 */
	uint32_t resetHandler_address=*(volatile uint32_t*)(FLASH_SECTOR2_BASE_ADDRESS+4);

	PF_APP_Reset_handler=(void*)resetHandler_address;

	printmsg("BL_DEBUG_MSG:App_Reset_Handler_Address : %#x\r\n",PF_APP_Reset_handler);

	/* 3. Jump to Reset Handler of The User_Application */
	PF_APP_Reset_handler();
}


void BootLoader_UART_Read_Host_CMD()
{
	uint8_t BL_rcv_len=0;
	uint8_t BL_cmd_code=0;
	while(1)
	{
		memset(BL_rx_buffer,0,BL_RX_LEN);
		/* Here we will Read and Decode Command coming form the Host */

		// 1.Read only one Byte from the Host, which is "LENGTH_FIELD" of the command Packet
		HAL_UART_Receive(C_UART,BL_rx_buffer,1,HAL_MAX_DELAY);
		BL_rcv_len=BL_rx_buffer[0];

		// 2.Read The Rest of the command packet according to Length i got from the user
		HAL_UART_Receive(C_UART,&BL_rx_buffer[1],BL_rcv_len,HAL_MAX_DELAY);

		// 3.The second Byte of The Packet is the "COMMAND_CODE" of the command packet
		BL_cmd_code=BL_rx_buffer[1];

		// 4.Use Switch case to Decode The Command Code and Give The Right Response according to CMD
		switch(BL_cmd_code)
		{
			case BL_GET_VER:
				BL_hanlde_getVersion_cmd(BL_rx_buffer);
				break;
			case BL_GET_HELP:
				BL_hanlde_getHelp_cmd(BL_rx_buffer);
				break;
			case BL_GET_CID:
				BL_hanlde_getCID_cmd(BL_rx_buffer);
				break;
			case BL_GET_RDP_STATUS:
				BL_hanlde_getRDP_cmd(BL_rx_buffer);
				break;
			case BL_GO_TO_ADDR:
				BL_hanlde_goAddress_cmd(BL_rx_buffer);
				break;
			case BL_FLASH_ERASE:
				BL_hanlde_flashErase_cmd(BL_rx_buffer);
				break;
			case BL_MEM_WRITE:
				BL_hanlde_memWrite_cmd(BL_rx_buffer);
				break;
			case BL_MEM_READ:
				BL_hanlde_memRead_cmd(BL_rx_buffer);
				break;
			case BL_READ_SECTOR_STATUS:
				BL_handle_ReadSectorStatus_cmd(BL_rx_buffer);
				break;
			default:
				printmsg("BL_DEBUG_MSG: INVALID COMMAND CODE RECEIVED FROM THE HOST\r\n");
		}
	}
}

/* This Function send ACK if CRC Matches with length of bytes of the reply */
void BootLoader_Send_ACK(uint8_t command_code , uint8_t length_of_reply)
{
	/* Here We Send Two Bytes
	 * 1st Byte is ACK
	 * 2nd Byte is The Length of The Coming Reply
	 */
	uint8_t ACK_buffer[2];
	ACK_buffer[0]= BL_ACK;
	ACK_buffer[1]= length_of_reply;
	HAL_UART_Transmit(C_UART,ACK_buffer,2,HAL_MAX_DELAY);
}

/* This Function sends NACK if CRC doesn't Matches */
void void BootLoader_Send_NACK(void)
{
	uint8_t NACK_buffer=BL_NACK;
	HAL_UART_Transmit(C_UART,&NACK_buffer,1,HAL_MAX_DELAY);
}

void BootLoader_Verify_CRC(uint8_t *pData ,uint32_t length ,uint32_t CRC_Host)
{
	uint32_t uwCRCValue=0xFF;

	for(uint32_t i=0 ; i<length ; i++)
	{
		// Convert Data from uint8_t to uint32_t
		uint32_t iData=pData[i];
		//Accumulate The CRC for each iteration of pData bytes
		uwCRCValue=HAL_CRC_Accumulate(&hcrc,&iData,1);
	}

	if(uwCRCValue==CRC_Host)
	{
		return VERIFY_CRC_SUCCESS;
	}
	else
	{
		return VERIFY_CRC_FAIL;
	}
}
/***************Implementation of Bootloader Command Handle Function*******************/
void BL_hanlde_getVersion_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_getHelp_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_getCID_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_getRDP_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_goAddress_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_flashErase_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_memWrite_cmd(uint8_t* pbuffer)
{

}
void BL_hanlde_memRead_cmd(uint8_t* pbuffer)
{

}
void BL_handle_ReadSectorStatus_cmd(uint8_t* pbuffer)
{

}
